# 任务

1. check mcts代码的正确性
2. 其他baseline代码
3. 更多的benchmark

# 基本想法

每个节点代表的是一种变量激活方式，根节点表示所有变量都激活(即都有概率被选择)。根据实际被选择变量采样样本和补样本(补样本很重要，因为这样保证了每个变量被采样次数相等)，然后累加各个维度的估值，对维度进行分类，找到好的维度(即f值更高的维度)。根节点的左节点表示

在被选择的节点，根据节点表示的变量选择方式，

# 具体实验细节

benchmark函数的变量范围怎么确定

## 消融实验

1. split时的依据：mean、median、kmeans。目前：mean
2. 重要的值确定方式：bo、turbo。目前：bo
3. 不重要值确定方式：random，bestk。目前：bestk
4. uct计算时，max、mean。目前：max

画图，在plot-util的363和413行加入

## 需要思考的

计算get_axis_score时使用feature采样的样本的最大值还是均值，目前是max

dynamic_treeify时是否需要建立一颗完整的树

backpropogate时，需要更新哪些东西，是否要向上传递所有的样本点

变量数量过小时，则把节点的估值变得特别低，不选择他，因为会引起gpr的bug，这个可不可以通过聚类选择代表的方式解决

会不会因为选择不重要变量后，每次重要变量都是选择的best，反而使得f比较高

为什么在优化有更多冗余变量的函数时表现反而更好
